
+++
read_time = 20
date = "2018-09-11"
title = "如何设计一个高性能可扩展的抽奖系统"
tags = ["系统设计","架构设计","软件设计"]
categories = ["general"]
draft = false
description = "本文从软件开发过程的不同阶段详解如何设计一个高性能可扩展的抽奖系统。"
weight = 86
+++

阅读人群：软件工程师   
您将收获：了解设计一个高性能可扩展的抽奖系统从需求到设计的全过程。

## 一、概述
> 本文从软件开发过程的不同阶段详解如何设计一个高性能可扩展的系统。

## 二、需求分析
### 2.1. 需求背景

最近公司准备在APP首页加入游戏元素，也是为了填补新版首页空缺的内容，故增加打开宝箱进行抽奖的需求。需求很简单就是在首页显示一个宝箱，用户点击宝箱有一定几率能获取到奖品（优惠券）。

需求整体分2部分：1部分是满足运营的基本需求，即抽奖活动、抽奖规则、抽奖奖品的基本配置。另一部分是用户端抽奖部分的流程和UI的设计和实现。


### 2.2. 需求梳理

首先将需求转换成思维导图，这里需要注意用户端和运营端的不同思维设计。梳理阶段可以是片面的，不用太过详细，把我们对需求的理解输出成思维导图。

<center>
<img src="http://assets.processon.com/chart_image/5b19f6b9e4b001a14d3282dc.png?_=1535698390638"/>

抽奖系统概要思维导图
</center>

下面两种思维方式有助于你设计一个系统：  
- [用户思维](http://www.woshipm.com/user-research/611865.html)  
- [结构化思维](http://www.woshipm.com/it/981307.html)  

## 三、应用设计

### 3.1. 用户端设计
<br>
<center>
<img src="https://os-qingdao.oss-cn-qingdao.aliyuncs.com/note/image/%E9%A6%96%E9%A1%B5%E6%94%B9%E5%8A%A8%E6%80%81%E6%95%88%E6%9E%9C.gif"/>

客户端的UI设计图
</center>

本次用户端设计主要注重以下几点：
- 简单（一看就知道怎么使用）
- 反馈（一点按钮就能知道有没有中奖）

我们将活动与用户的关系在不同时态上都有不同的表达。例如：活动开始前宝箱灰色调按钮、活动进行时按钮变成可用、活动后提示已结束；实际上这只是以用户的角度对时间维度的不同表现形势做出反馈而已。当然，我们会在活动开始前发送推文让用户对活动可获得奖品有一定了解，让利的幅度足够使用户期待。


### 3.2. 管理运营端设计

利用结构化思维将管理运营端设计步骤分成3步：
- 罗列功能列表项
- 功能归类成模块
- 模块间依赖关系

**罗列功能列表项**

<center>
<img src="http://assets.processon.com/chart_image/5b8b7397e4b0bd4db927ca82.png?_=1536067121462"/>

运营端活动功能列表图
</center>

这个很好理解，将我们对需求的理解列出一项项功能；例如：抽奖活动应该有创建活动、活动上下架和活动列表等功能。这里使用MECE原则穷尽功能项。

**功能归类成模块**

<center>
<img src="http://assets.processon.com/chart_image/5b889a8de4b06fc64addc7ee.png?_=1536073279624"/>

运营端活动模块图
</center>

将一组推测出具有相同性质的功能且之间存在自然关系的一个个功能项虚拟出类别（即模块）。归类的好处除了便于管理和记忆外，还能使我们从杂乱的信息中找出事物的规律；是促进构建系统的关键步骤，也是快速构建模型的一种方式。当我们使用三层或四层架构开发时，能够快速的将归类好的功能模块对应到不同层进行开发。

**模块间依赖关系**

画出我们分好的功能模块依赖间关系图：

<center>
<img src="http://assets.processon.com/chart_image/5b895db3e4b06fc64adf4cce.png"/>

功能模块依赖间关系图
</center>


依赖关系图也可以叫数据流向图，可在开发过程中对比此图来完善业务数据的逻辑。从而保证严谨的数据一致性，减少应数据不一致导致的各种bug。


**小结**

管理运营端的设计偏结构化，设计的关键要点是理解目标用户的基本功能需求，在此基础上推出功能列表；然后采用三步走迭代几次可得相对完善的系统结构。下面是迭代后的功能模块：

<center>
<img src="http://assets.processon.com/chart_image/5b8e7ee5e4b075b9fe36c46d.png?_=1536116735687"/>

管理运营端功能模块结构图
</center>

### 3.3. API 服务端设计

API服务端是用户端和运营端抽象出来的副产品，具有向上提供接口服务用户端，向下使用运营端提供的活动配置和数据模型来支撑业务。服务端主要关注稳定、性能和扩展。API 服务的设计主要从**明确用户接**口和**服务交互设计**着手。

**明确用户接口**

从用户端设计中我们可以得出以下的接口：  
- 抽奖接口（开启宝箱）  
- 当前是否有活动（可忽略）  

**服务交互设计**

下面是用户端、运营端和API服务端的整体交互流程图：

<center>
<img src="https://os-qingdao.oss-cn-qingdao.aliyuncs.com/note/image/draw-system.png"/>

整体交互流程图
</center>


**考虑因数**

- 服务的目标用户数
- 每秒需承受的请求量
- 中奖信息的及时性

从需求就可以知道这是一个高频低延时应用，所以在设计时应尽可能多的满足更多用户的请求，并能在有限时间内响应。故将**抽奖接口拆分成抽奖受理接口和查询中奖记录接口**。受理接口接收到请求并必要性校验后生成一个queryId作为应答信息，用户端用queryId去请求中奖记录接口，如果未获取则等待再次请求，直到有中奖应答信息为止。

<center>
<img src="http://assets.processon.com/chart_image/5b8f7621e4b0d4d65bf70804.png"/>

客户端抽奖流程接入指引图
</center>

上图是用户端接入的流程指引，
为了使服务端处理更多的请求，故将部分逻辑放到客户端去处理；从而减轻服务端的压力，提高系统吞吐量。

## 四、系统架构设计

<center>
<img src="http://assets.processon.com/chart_image/5b8502bbe4b0d4d65bea5e4f.png?_=1536119077482"/>

系统架构设计图
</center>

**核心的设计目的**就是通过网关负载层将请求循环分发到API应用实例内，从而增加整体系统的吞吐量。再结合消息中间件同步奖品池、统计等服务的数据，达到不同实例间数据的交换和通信。使用 redis 暂存抽奖中奖记录、奖品箱等数据来提高程序性能。下面将介绍关键服务：分发服务、抽奖服务、发奖服务、计数服务、存储服务和查询服务的设计。


### 4.1. 分发服务

主要有分发活动奖品和下发规则等作用

<center>
<img src="http://assets.processon.com/chart_image/5b8f9d07e4b06fc64ae6058b.png"/>

分发服务流程图
</center>

运营人员上线活动时运营系统将活动信息发布到 rabbitmq exchange topic 中，分发服务订阅 topic 并接收 rabbitmq  推送的消息。然后从 eureka 中获取 API应用 实例列表并计算出每个实例分配多少奖品，然后将结果发送到 rabbitmq exchange fanout，由 rabbitmq 将消息广播到API应用实例的分发服务中。在经由分发服务将活动信息保存到本地和redis中给后续依赖的服务使用。

**如何保证公平分发？**
使用 rabbitmq 循环分发策略保证只有一个实例接收到消息，在经由接收到消息的 API应用 实例计算每个实例分配多少，然后广播到所有 API应用实例；每个抽奖服务实例比对自己分得多少的同时检查是否有服务实例 down 掉，如果有则从新计算并广播消息，这时每个服务实例都会接收到API应用实例数量的消息，据时间排序所有消息并以最快的那一条消息为准，用这种事先定好的契约来确定出 master。下面给出一个示例的消息结构：

```
# 原始消息
{
    msgId:10001:add,//消息ID,来自活动ID为10001的数据
    prize:100:coupon//奖品,活动发布了100张优惠券  
}

# 实例广播消息
{
    msgId:10001:add,//消息ID,来自活动ID为10001的数据
    prize:100:coupon,//奖品,活动发布了100张优惠券
    createTime:1536291005738,//创建时间
    instances:[
        {
            instanceId:192.168.35.15:LOTTERY-SERVER:8081, //实例ID
            prize:34:coupon //分配到的奖品信息
        },
        {
            instanceId:192.168.35.16:LOTTERY-SERVER:8081,//实例ID
            prize:33:coupon //分配到的奖品信息
        },
        {
            instanceId:192.168.35.17:LOTTERY-SERVER:8081,//实例ID
            prize:33:coupon //分配到的奖品信息
        }
    ]
}
```
**其他需要思考处理的问题**

- 已分配的抽奖实例down了或hang了如何将剩余奖品同步到其他服务？
- 已恢复的抽奖实例如何在不影响其他服务正常运转的情况下从新分配奖品？
- ...

**分发服务的设计核心思想是每个API应用实例都是master**，利用rabbitmq 循环分发机制可以让每个服务实例都有机会当master，每个服务实例都遵守事先约定好的契约，当增加实例或实例退出时程序按契约条款能正确处理数据。

### 4.2. 计数服务

主要提供各类原子统计API和系统各种统计指标

<center>
<img src="http://assets.processon.com/chart_image/5b921ce7e4b0534c9bd01f40.png"/>

计数服务流程图
</center>

计数服务主要分两部分，一部分是应用本地统计，另一部分是应用间合并统计。具有奖品统计、用户统计等功能。计数服务的统计由分发服务和存储服务触发。

### 4.3. 抽奖服务

主要有受理抽奖和抽奖的作用

<center>
<img src="http://assets.processon.com/chart_image/5b912a9fe4b0534c9bcf26ee.png"/>

抽奖服务流程图
</center>

抽奖服务的组成由一个是受理抽奖接口和一个处理抽奖的工作线程。会员请求抽奖受理接口快速响应受理结果，程序将已受理的信息发送到本地抽奖队列中。抽奖工作线程取出已受理的信息并进行验证统计，验证成功后抽取抽奖资格，成功则将中奖信息发送到中奖队列中。

**为什么不直接获取抽奖结果？**
抽奖这个过程因尽量减少每一步使用锁和占用锁的机会和时间，而抽奖资格箱会过滤绝大部分请求，最终获取到抽奖资格的一般都能获取到奖品，如果高并发下超出中奖奖品数量时会使用先到先得的模式发放奖品。利用队列也是一种无锁的设计方式，在这个抽奖场景中使用FIFO模式也相对公平合理。

### 4.4. 发奖服务

主要有发放前检验和发放奖品功能

<center>
<img src="http://assets.processon.com/chart_image/5b91f4cee4b0d4d65bfacde9.png"/>

发奖服务流程图
</center>

发奖服务就是一个处理发奖的工作线程，通过拉取中奖队列消息来获取中奖的信息，并进行必要的发奖前检验和统计。通过后则进行真正的发奖和统计。

### 4.5. 存储服务

存储服务使用类似Redis RDB机制，先将数据存储到内存，然后当数据累计达到设定阈值或时间段内会触发一次持久化操作，将变化的数据一次性写入redis和mysql（只存储业务需要数据）。

<center>
<img src="http://assets.processon.com/chart_image/5b923711e4b0d4d65bfb7401.png"/>

存储服务流程图
</center>

可以在计数服务增加指标使存储服务的提交策略更灵活。


### 4.6. 查询服务

查询服务分2部分，一部分是业务长期使用的数据，另一部分是短期需要的数据。
长期数据一般是中奖记录，而短期数据一般是会员及时查询的数据（例如：查询抽奖记录）。这些数据的生命存活时间有长有短，针对不同时长查询不同的数据存储库。

<center>
<img src="http://assets.processon.com/chart_image/5b95e71be4b0fe81b62dc0c1.png"/>

查询服务流程图
</center>

对于抽奖结果查询这种生命周期短的业务，先在本地缓存查找，找不到则到redis找。而管理运营端中奖记录的查询则走mysql数据库。


### 4.7. 小结

本次架构设计主要是从“分而治之”出发，从源头将数据分离到各个API应用实例中，让活动期间产生的计算、锁、持久化和查询等动作都在API应用实例内完成。实例每隔一段时间会按事先约定的契约产生一个master，由他来负责数据同步并发送计算结果到代理人（rabbitmq），由代理人将消息广播到各个参与者（API应用实例）。从而使数据同步到各个实例内，达到“合而分之”。


## 五、系统优化

- 应用服务器调优
- 减少没必要的请求调用
- 优化契约各个数据结构
- 客户端实现背压机制

## 六、总结

这篇文章我分享了我设计一个系统使用的一些经验和技巧。首先是如何梳理需求，我的一个习惯是使用思维导图，导图呈现的视图能让我有效的持续改进设计逻辑及关联关系。

然后是设计用户端需要以用户思维（用户思维≠换位思考）去思考设计，在管理端以结构化思维去思考设计。并推荐了2篇关于用户思维和结构化思维的文章。

最后是设计一个高性能可扩展系统需要关注的点，以及点与点之间如何交互。只有在理清这些之后才能行之有效的设计系统，通过交互图、架构图和流程图阐述设计的核心思想。
